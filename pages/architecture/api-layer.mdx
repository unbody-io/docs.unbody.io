import { Callout } from 'nextra/components'

# **API Layer**

The **API Layer** is how you interact with Unbody’s backend. It provides a set of programmatic interfaces for managing data, retrieving enriched content, and integrating AI-native capabilities into your applications. Designed to be intuitive and flexible, the API Layer supports a wide range of use cases, from querying vectorized data to managing custom schemas.

Unbody's API Layer is divided into several components, each serving a specific purpose. Here’s how they work:

---


 
<Callout>
  Unbody provides a **Typescript SDK** for all APIs, making integration simpler and more efficient. The SDK abstracts low-level API calls, so you can focus on building functionality without worrying about the details of HTTP requests.
</Callout>

### GraphQL API

The GraphQL API is the central interface for interacting with Unbody’s processed and vectorized data. It supports both **retrieval** and **generation** workflows:

- **Retrieval**: Query enriched or vectorized data directly. Retrieve documents, perform similarity searches, or filter results based on metadata.
- **Generation**: Leverage AI models integrated with Unbody to generate new content such as summaries, Q&A responses, or translations.

Since Unbody uses **Weaviate** as its primary database, the GraphQL API is essentially a mirror of Weaviate’s interface with Unbody’s classes layered on top. This means developers familiar with Weaviate will find the GraphQL API intuitive and straightforward to use.

GraphQL allows you to request exactly what you need, minimizing redundant data transfers. It’s flexible, powerful, and works seamlessly with Unbody’s architecture.

---

### Admin API

The Admin API is designed for **managing projects, sources, and configurations programmatically**, bypassing the need for dashboard interaction. This is ideal for automation and team-based workflows.

With the Admin API, you can:

- Create, update, and delete projects.
- Add, remove, or monitor data sources.
- Configure enrichment pipelines, vectorizers, chunking strategies, and more.

The Admin API is particularly useful for automating large-scale workflows, especially when managing multiple projects or integrating with CI/CD pipelines.

---

### Push API

The Push API handles **custom data ingestion**. It enables you to define your own schemas and programmatically send data to Unbody. This is especially useful for non-standard data sources or highly specialized workflows.

**How It Works**:

1. Define a custom schema at the project level using the Admin API or dashboard.
2. Push data to Unbody via the Push API.
3. Use the Admin API or dashboard to monitor the status and ensure the data is processed.

This flexibility makes Unbody adaptable to unique use cases where prebuilt integrations aren’t enough.

---

### Image API

The Image API is powered by **Imgix** and supports advanced image processing for AI-native and traditional workflows. It offers both **basic functionality** and **AI-driven enhancements**:

- **Basic Processing**: Resize, crop, or optimize images for delivery.
- **AI-Driven Features**: Detect and crop faces, remove backgrounds, and apply image prompts.

The Image API is available exclusively in **Unbody Cloud** (not open-source). Long-term plans include extending this functionality to the open-source version.

---

### Audio/Video API

The Audio/Video API is powered by **Mux** and is designed for hosting and streaming multimedia content. It integrates seamlessly with Unbody’s workflows to handle:

- **Video Hosting**: Upload and stream videos with metadata tagging and automatic thumbnail generation.
- **Audio Streaming**: Deliver audio files efficiently with AI-based enhancements.
- **AI Integrations**: Extract transcripts, apply keyword tagging, and even perform speaker identification for media files.

Like the Image API, the Audio/Video API is exclusive to **Unbody Cloud**. Supporting these features in open-source Unbody is a long-term goal.

---

### What’s Next?

The API Layer bridges your application and Unbody’s backend. For integrating the outputs into your frontend, explore the [Frontend Layer](/frontend-layer).